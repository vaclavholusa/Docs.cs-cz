---
uid: web-api/overview/error-handling/web-api-global-error-handling
title: Globální zpracování chyb v rozhraní ASP.NET Web API 2 | Dokumentace Microsoftu
author: davidmatson
description: ''
ms.author: aspnetcontent
manager: wpickett
ms.date: 02/03/2014
ms.topic: article
ms.assetid: bffd7863-f63b-4b23-a13c-372b5492e9fb
ms.technology: dotnet-webapi
msc.legacyurl: /web-api/overview/error-handling/web-api-global-error-handling
msc.type: authoredcontent
ms.openlocfilehash: 8703ea4c20003148c330bcd534ccacc1dc72c850
ms.sourcegitcommit: 953ff9ea4369f154d6fd0239599279ddd3280009
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 07/03/2018
ms.locfileid: "37377828"
---
<a name="global-error-handling-in-aspnet-web-api-2"></a><span data-ttu-id="ea3a9-102">Globální zpracování chyb v rozhraní ASP.NET Web API 2</span><span class="sxs-lookup"><span data-stu-id="ea3a9-102">Global Error Handling in ASP.NET Web API 2</span></span>
====================
<span data-ttu-id="ea3a9-103">podle [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-103">by [David Matson](https://github.com/davidmatson), [Rick Anderson](https://github.com/Rick-Anderson)</span></span>

<span data-ttu-id="ea3a9-104">V rozhraní API webových protokolů nebo globálně zpracování chyb, které dnes není jednoduchý způsob.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-104">Today there's no easy way in Web API to log or handle errors globally.</span></span> <span data-ttu-id="ea3a9-105">Některé neošetřené výjimky lze zpracovat prostřednictvím [filtry výjimek](exception-handling.md), ale existuje několik případů, které nemůže zpracovat filtry výjimek.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-105">Some unhandled exceptions can be processed via [exception filters](exception-handling.md), but there are a number of cases that exception filters can't handle.</span></span> <span data-ttu-id="ea3a9-106">Příklad:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-106">For example:</span></span>

1. <span data-ttu-id="ea3a9-107">Výjimky vyvolané z konstruktorů kontroleru.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-107">Exceptions thrown from controller constructors.</span></span>
2. <span data-ttu-id="ea3a9-108">Výjimky vyvolané z obslužné rutiny zpráv.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-108">Exceptions thrown from message handlers.</span></span>
3. <span data-ttu-id="ea3a9-109">Výjimky vyvolané při směrování.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-109">Exceptions thrown during routing.</span></span>
4. <span data-ttu-id="ea3a9-110">Výjimky vyvolané během serializace obsahu odpovědí.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-110">Exceptions thrown during response content serialization .</span></span>

<span data-ttu-id="ea3a9-111">Chceme poskytnout jednoduchý a konzistentní způsob, jak protokolování a zpracování (Pokud je to možné) tyto výjimky.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-111">We want to provide a simple, consistent way to log and handle (where possible) these exceptions.</span></span> 

<span data-ttu-id="ea3a9-112">Existují dva hlavní případy pro zpracování výjimek, v případě, že nemůžeme poslat reakce na chybu a je případ, kdy všechny můžeme udělat protokolu výjimku.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-112">There are two major cases for handling exceptions, the case where we are able to send an error response and the case where all we can do is log the exception.</span></span> <span data-ttu-id="ea3a9-113">Příklad pro druhém případě je při vyvolání výjimky uprostřed streamování obsahu odpovědi; v takovém případě je příliš pozdě odeslat nové zprávy odpovědi, protože stavový kód, záhlaví a Částečný obsah již šly voláním sítí, takže můžeme jednoduše přerušit připojení.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-113">An example for the latter case is when an exception is thrown in the middle of streaming response content; in that case it is too late to send a new response message since the status code, headers, and partial content have already gone across the wire, so we simply abort the connection.</span></span> <span data-ttu-id="ea3a9-114">Přestože výjimky nelze zpracovat k vytvoření nové zprávy odpovědi, stále podporovat protokolování výjimky.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-114">Even though the exception can't be handled to produce a new response message, we still support logging the exception.</span></span> <span data-ttu-id="ea3a9-115">V případech, kde můžeme detekovat chyby jsme vrátit odpověď příslušnou chybovou, jak je znázorněno v následujících tématech:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-115">In cases where we can detect an error, we can return an appropriate error response as shown in the following:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample1.cs?highlight=6)]

### <a name="existing-options"></a><span data-ttu-id="ea3a9-116">Stávající možnosti</span><span class="sxs-lookup"><span data-stu-id="ea3a9-116">Existing Options</span></span>

<span data-ttu-id="ea3a9-117">Kromě [filtry výjimek](exception-handling.md), [obslužné rutiny zpráv](../advanced/http-message-handlers.md) je možné ještě dnes sledovat všechny odpovědi na úrovni 500, ale reagovat na tyto odpovědi je obtížné, protože nemají kontextu o původní chyby.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-117">In addition to [exception filters](exception-handling.md), [message handlers](../advanced/http-message-handlers.md) can be used today to observe all 500-level responses, but acting on those responses is difficult, as they lack context about the original error.</span></span> <span data-ttu-id="ea3a9-118">Obslužné rutiny zpráv mají také některé stejná omezení jako filtry výjimek, pokud jde o případy, které dokáže zpracovat. Webové rozhraní API se trasování infrastruktury, který zachytává chybové stavy sledování infrastruktury je pro účely diagnostiky a není určená nebo vhodný pro spouštění v produkčním prostředí.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-118">Message handlers also have some of the same limitations as exception filters regarding the cases they can handle.While Web API does have tracing infrastructure that captures error conditions the tracing infrastructure is for diagnostics purposes and is not designed or suited for running in production environments.</span></span> <span data-ttu-id="ea3a9-119">Globální zpracování výjimek a protokolování by měl být služeb, které lze spustit během produkčního prostředí a zapojí se do existujícího řešení monitorování (třeba [ELMAH](https://code.google.com/p/elmah/) ).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-119">Global exception handling and logging should be services that can run during production and be plugged into existing monitoring solutions (for example, [ELMAH](https://code.google.com/p/elmah/) ).</span></span>

### <a name="solution-overview"></a><span data-ttu-id="ea3a9-120">Přehled řešení</span><span class="sxs-lookup"><span data-stu-id="ea3a9-120">Solution Overview</span></span>

 <span data-ttu-id="ea3a9-121">Nabízíme dvě nové služby replaceable uživatele [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) a IExceptionHandler, protokolování a zpracování neošetřených výjimek.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-121">We provide two new user-replaceable services, [IExceptionLogger](../releases/whats-new-in-aspnet-web-api-21.md) and IExceptionHandler, to log and handle unhandled exceptions.</span></span> <span data-ttu-id="ea3a9-122">Služby jsou velmi podobné, dva hlavní rozdíly:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-122">The services are very similar, with two main differences:</span></span>

1. <span data-ttu-id="ea3a9-123">Podporujeme registrace protokolovačů více výjimek, ale pouze jeden výjimka obslužné rutiny.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-123">We support registering multiple exception loggers but only a single exception handler.</span></span>
2. <span data-ttu-id="ea3a9-124">Protokolovací nástroje výjimka získat volána vždy, i v případě, že jsme se chystáte přerušit připojení.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-124">Exception loggers always get called, even if we're about to abort the connection.</span></span> <span data-ttu-id="ea3a9-125">Obslužné rutiny výjimek pouze získat volá se, když jsme stále možnost rozhodnout, jaké zprávy s odpovědí k odeslání.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-125">Exception handlers only get called when we're still able to choose which response message to send.</span></span>

<span data-ttu-id="ea3a9-126">Obě služby poskytují přístup ke kontextu výjimky obsahující příslušné informace z bodu, kde byla zjištěna výjimka, zejména [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), vyvolána výjimka a zdroj výjimky (viz podrobnosti níže).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-126">Both services provide access to an exception context containing relevant information from the point where the exception was detected, particularly the [HttpRequestMessage](https://msdn.microsoft.com/library/system.net.http.httprequestmessage(v=vs.110).aspx), the [HttpRequestContext](https://msdn.microsoft.com/library/system.web.http.controllers.httprequestcontext(v=vs.118).aspx), the thrown exception and the exception source (details below).</span></span>

### <a name="design-principles"></a><span data-ttu-id="ea3a9-127">Principy návrhu</span><span class="sxs-lookup"><span data-stu-id="ea3a9-127">Design Principles</span></span>

1. <span data-ttu-id="ea3a9-128">**Žádné významné změny** vzhledem k tomu, že tato funkce se přidává vedlejší verze, jeden je důležité omezení dopadu na řešení, která existovat žádné významné změny, buď na typ smlouvy nebo chování.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-128">**No breaking changes** Because this functionality is being added in a minor release, one important constraint impacting the solution is that there be no breaking changes, either to type contracts or to behavior.</span></span> <span data-ttu-id="ea3a9-129">Toto omezení vyloučit některé vyčištění, které rádi bychom Nedokázali, co se týče stávající bloky catch zapnutí výjimky na 500 odpovědi.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-129">This constraint ruled out some cleanup we would like to have done in terms of existing catch blocks turning exceptions into 500 responses.</span></span> <span data-ttu-id="ea3a9-130">Tato další vyčištění je něco, co jsme zvážit další hlavní verze.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-130">This additional cleanup is something we might consider for a subsequent major release.</span></span> <span data-ttu-id="ea3a9-131">Pokud to je důležité si prosím hlasovat o ji do [hlas uživatelů ASP.NET Web API](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-131">If this is important to you please vote on it at [ASP.NET Web API user voice](http://aspnet.uservoice.com/forums/147201-asp-net-web-api/suggestions/5451321-add-flag-to-enable-iexceptionlogger-and-iexception).</span></span>
2. <span data-ttu-id="ea3a9-132">**Zachování konzistence s webovým rozhraním API vytvoří** filtr kanál rozhraní Web API je skvělý způsob, jak zpracovat vyskytující aspekty s flexibilitou použití logiky na konkrétní akci, kontroler konkrétní nebo globální obor.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-132">**Maintaining consistency with Web API constructs** Web API's filter pipeline is a great way to handle cross-cutting concerns with the flexibility of applying the logic at an action-specific, controller-specific or global scope.</span></span> <span data-ttu-id="ea3a9-133">Filtry, včetně filtry výjimek, akce a kontroler kontextů, mají vždy, i v případě, že je zaregistrované v globálním oboru.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-133">Filters, including exception filters, always have action and controller contexts, even when registered at the global scope.</span></span> <span data-ttu-id="ea3a9-134">Existuje, že kontrakt dává smysl pro filtry, ale znamená, že nejsou filtry výjimek, i s globálním oborem. ty, které jsou vhodné pro některé výjimky zpracování případů, jako jsou například výjimky z obslužné rutiny zpráv, pokud žádný kontext akce nebo kontroleru.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-134">That contract makes sense for filters, but it means that exception filters, even globally scoped ones, aren't a good fit for some exception handling cases, such as exceptions from message handlers, where no action or controller context exists.</span></span> <span data-ttu-id="ea3a9-135">Pokud chcete používat flexibilní oborů poskytované filtry pro zpracování výjimek, potřebujeme ještě filtry výjimek.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-135">If we want to use the flexible scoping afforded by filters for exception handling, we still need exception filters.</span></span> <span data-ttu-id="ea3a9-136">Ale pokud bychom někdy potřebovali zpracovat výjimku mimo kontext kontroleru, potřebujeme také samostatnou konstrukci pro zpracování chyb celosvětovým (něco bez kontroleru kontextu a akce kontextu omezení).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-136">But if we need to handle exception outside of a controller context, we also need a separate construct for full global error handling (something without the controller context and action context constraints).</span></span>

### <a name="when-to-use"></a><span data-ttu-id="ea3a9-137">Kdy použít</span><span class="sxs-lookup"><span data-stu-id="ea3a9-137">When to Use</span></span>

- <span data-ttu-id="ea3a9-138">Protokolovací nástroje výjimky jsou řešení tak, aby zobrazuje všechny neošetřené výjimky zachycuje se prostřednictvím webového rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-138">Exception loggers are the solution to seeing all unhandled exception caught by Web API.</span></span>
- <span data-ttu-id="ea3a9-139">Obslužné rutiny výjimek jsou řešení pro přizpůsobení všechny možné odpovědi na neošetřených výjimkách zachycených v rozhraní Web API.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-139">Exception handlers are the solution for customizing all possible responses to unhandled exceptions caught by Web API.</span></span>
- <span data-ttu-id="ea3a9-140">Filtry výjimek jsou nejjednodušší řešení pro zpracování dílčí neošetřené výjimky související s konkrétní akce nebo kontroleru.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-140">Exception filters are the easiest solution for processing the subset unhandled exceptions related to a specific action or controller.</span></span>

### <a name="service-details"></a><span data-ttu-id="ea3a9-141">Podrobnosti služby</span><span class="sxs-lookup"><span data-stu-id="ea3a9-141">Service Details</span></span>

 <span data-ttu-id="ea3a9-142">Rozhraní služeb protokolovací nástroj a obslužné rutiny výjimek jsou jednoduché asynchronní metody provádění příslušných kontextech:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-142">The exception logger and handler service interfaces are simple async methods taking the respective contexts:</span></span> 

[!code-csharp[Main](web-api-global-error-handling/samples/sample2.cs)]

 <span data-ttu-id="ea3a9-143">Poskytujeme také základní třídy pro oba z těchto rozhraní.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-143">We also provide base classes for both of these interfaces.</span></span> <span data-ttu-id="ea3a9-144">Přepsání metody core (synchronizace nebo asynchronní) je vše, co je potřeba přihlášení nebo zpracování na doporučenou dobu.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-144">Overriding the core (sync or async) methods is all that is required to log or handle at the recommended times.</span></span> <span data-ttu-id="ea3a9-145">Pro protokolování, `ExceptionLogger` základní třídy se zajistí, že metoda základní protokolování je volat pouze jednou pro každou výjimku (i v případě, že ji později postoupí dále až zásobníku volání a zachycuje se znovu).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-145">For logging, the `ExceptionLogger` base class will ensure that the core logging method is only called once for each exception (even if it later propagates further up the call stack and is caught again).</span></span> <span data-ttu-id="ea3a9-146">`ExceptionHandler` Základní třídu bude volat základní metodu zpracování pouze pro výjimky v horní části zásobníku volání, ignoruje se starší verze vnořené bloky catch.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-146">The `ExceptionHandler` base class will call the core handling method only for exceptions at the top of the call stack, ignoring legacy nested catch blocks.</span></span> <span data-ttu-id="ea3a9-147">(Zjednodušená verze těchto základních tříd jsou dále v příloze.) Obě `IExceptionLogger` a `IExceptionHandler` získat informace o výjimce prostřednictvím `ExceptionContext`.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-147">(Simplified versions of these base classes are in the appendix below.) Both `IExceptionLogger` and `IExceptionHandler` receive information about the exception via an `ExceptionContext`.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample3.cs)]

<span data-ttu-id="ea3a9-148">Když rozhraní volá protokolovač výjimek nebo obslužnou rutinu výjimky, bude vždy poskytovat `Exception` a `Request`.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-148">When the framework calls an exception logger or an exception handler, it will always provide an `Exception` and a `Request`.</span></span> <span data-ttu-id="ea3a9-149">Výjimkou je testování částí, bude také vždy poskytovat `RequestContext`.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-149">Except for unit testing, it will also always provide a `RequestContext`.</span></span> <span data-ttu-id="ea3a9-150">Bude poskytovat jen zřídka `ControllerContext` a `ActionContext` (pouze při volání z bloku catch pro filtry výjimek).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-150">It will rarely provide a `ControllerContext` and `ActionContext` (only when calling from the catch block for exception filters).</span></span> <span data-ttu-id="ea3a9-151">Bude poskytovat jen velmi zřídka `Response`(pouze v určitých případech služba IIS při uprostřed při zápisu odpovědi).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-151">It will very rarely provide a `Response`(only in certain IIS cases when in the middle of trying to write the response).</span></span> <span data-ttu-id="ea3a9-152">Upozorňujeme, že některé z těchto vlastností mohou být `null` je až příjemce bude moct vyhledat `null` před přístup ke členům třídy výjimek.`CatchBlock`</span><span class="sxs-lookup"><span data-stu-id="ea3a9-152">Note that because some of these properties may be `null` it is up to the consumer to check for `null` before accessing members of the exception class.`CatchBlock`</span></span> <span data-ttu-id="ea3a9-153">je řetězec určující, které bloku catch viděli výjimky.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-153">is a string indicating which catch block saw the exception.</span></span> <span data-ttu-id="ea3a9-154">Řetězce bloku catch se následujícím způsobem:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-154">The catch block strings are as follows:</span></span>

- <span data-ttu-id="ea3a9-155">HttpServer (metoda SendAsync)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-155">HttpServer (SendAsync method)</span></span>
- <span data-ttu-id="ea3a9-156">HttpControllerDispatcher (metoda SendAsync)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-156">HttpControllerDispatcher (SendAsync method)</span></span>
- <span data-ttu-id="ea3a9-157">HttpBatchHandler (metoda SendAsync)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-157">HttpBatchHandler (SendAsync method)</span></span>
- <span data-ttu-id="ea3a9-158">Iexceptionfilter. (objektu ApiController zpracování kanálu filtru výjimky v ExecuteAsync)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-158">IExceptionFilter (ApiController's processing of the exception filter pipeline in ExecuteAsync)</span></span>
- <span data-ttu-id="ea3a9-159">OWIN hostitele:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-159">OWIN host:</span></span>

    - <span data-ttu-id="ea3a9-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (pro ukládání do výstupní vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-160">HttpMessageHandlerAdapter.BufferResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="ea3a9-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (pro streamování výstup)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-161">HttpMessageHandlerAdapter.CopyResponseContentAsync (for streaming output)</span></span>
- <span data-ttu-id="ea3a9-162">Webového hostitele:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-162">Web host:</span></span>

    - <span data-ttu-id="ea3a9-163">HttpControllerHandler.WriteBufferedResponseContentAsync (pro ukládání do výstupní vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-163">HttpControllerHandler.WriteBufferedResponseContentAsync (for buffering output)</span></span>
    - <span data-ttu-id="ea3a9-164">HttpControllerHandler.WriteStreamedResponseContentAsync (pro streamování výstup)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-164">HttpControllerHandler.WriteStreamedResponseContentAsync (for streaming output)</span></span>
    - <span data-ttu-id="ea3a9-165">HttpControllerHandler.WriteErrorResponseContentAsync (pro selhání v zotavení z chyb v režimu výstup do vyrovnávací paměti)</span><span class="sxs-lookup"><span data-stu-id="ea3a9-165">HttpControllerHandler.WriteErrorResponseContentAsync (for failures in error recovery under buffered output mode)</span></span>

<span data-ttu-id="ea3a9-166">Seznam řetězců blok catch, které je také k dispozici prostřednictvím vlastnosti statické jen pro čtení.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-166">The list of catch block strings is also available via static readonly properties.</span></span> <span data-ttu-id="ea3a9-167">(Řetězce bloku catch core jsou na statické ExceptionCatchBlocks; zbývající objeví na jednu statickou třídu každý pro OWIN a webového hostitele).`IsTopLevelCatchBlock`</span><span class="sxs-lookup"><span data-stu-id="ea3a9-167">(The core catch block string are on the static ExceptionCatchBlocks; the remainder appear on one static class each for OWIN and web host).`IsTopLevelCatchBlock`</span></span> <span data-ttu-id="ea3a9-168">je užitečné pro postup dle doporučený model zpracování výjimek pouze v horní části zásobníku volání.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-168">is helpful for following the recommended pattern of handling exceptions only at the top of the call stack.</span></span> <span data-ttu-id="ea3a9-169">Místo vypnutí výjimky na 500 odpovědi všude, kde dojde k vnořené zachytávací blok, můžete nechat obslužné rutiny výjimek výjimky nešířily, dokud mají vidět hostitele.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-169">Rather than turning exceptions into 500 responses anywhere a nested catch block occurs, an exception handler can let exceptions propagate until they are about to be seen by the host.</span></span>

<span data-ttu-id="ea3a9-170">Kromě `ExceptionContext`, získá protokolovač jeden kousek informace prostřednictvím plně `ExceptionLoggerContext`:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-170">In addition to the `ExceptionContext`, a logger gets one more piece of information via the full `ExceptionLoggerContext`:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample4.cs)]

<span data-ttu-id="ea3a9-171">Druhá vlastnost `CanBeHandled`, umožňuje protokolovací nástroj k identifikaci výjimku, která nelze zpracovat.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-171">The second property, `CanBeHandled`, allows a logger to identify an exception that cannot be handled.</span></span> <span data-ttu-id="ea3a9-172">Při připojení je dojít k přerušení a nelze odesílat žádné nové zprávy odpovědi, zavolá se Protokolovací nástroje, ale bude obslužnou rutinu ***není*** volat, a protokolovací nástroje můžete identifikovat tento scénář z této vlastnosti.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-172">When the connection is about to be aborted and no new response message can be sent, the loggers will be called but the handler will ***not*** be called, and the loggers can identify this scenario from this property.</span></span>

<span data-ttu-id="ea3a9-173">V další `ExceptionContext`, obslužná rutina načte jeden další vlastnosti můžete nastavit na plné `ExceptionHandlerContext` pro zpracování výjimky:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-173">In additional to the `ExceptionContext`, a handler gets one more property it can set on the full `ExceptionHandlerContext` to handle the exception:</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample5.cs)]

<span data-ttu-id="ea3a9-174">Obslužná rutina výjimky označuje, že ošetřila výjimku tak, že nastavíte `Result` vlastnost výsledek akce (například [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [ StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), nebo vlastní výsledek).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-174">An exception handler indicates that it has handled an exception by setting the `Result` property to an action result (for example, an [ExceptionResult](https://msdn.microsoft.com/library/system.web.http.results.exceptionresult(v=vs.118).aspx), [InternalServerErrorResult](https://msdn.microsoft.com/library/system.web.http.results.internalservererrorresult(v=vs.118).aspx), [StatusCodeResult](https://msdn.microsoft.com/library/system.web.http.results.statuscoderesult(v=vs.118).aspx), or a custom result).</span></span> <span data-ttu-id="ea3a9-175">Pokud `Result` vlastnost má hodnotu null, je výjimka neošetřená a bude původní výjimka znovu vyvolána.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-175">If the `Result` property is null, the exception is unhandled and the original exception will be re-thrown.</span></span>

<span data-ttu-id="ea3a9-176">Výjimky v horní části zásobníku volání nám trvalo přidat další krok k zajištění, že odpověď je vhodné pro volání rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-176">For exceptions at the top of the call stack, we took an extra step to ensure the response is appropriate for API callers.</span></span> <span data-ttu-id="ea3a9-177">Pokud se výjimka šíří do hostitele, volající by zobrazí žlutý obrazovka úmrtí nebo některé hostitel k dispozici odpověď, která je obvykle ve formátu HTML a není obvykle vhodné chybová odpověď rozhraní API.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-177">If the exception propagates up to the host, the caller would see the yellow screen of death or some other host provided response which is typically HTML and not usually an appropriate API error response.</span></span> <span data-ttu-id="ea3a9-178">V těchto případech výsledku spustí jinou hodnotu než null a pouze v případě, že obslužná rutina vlastní výjimky explicitně nastaví zpět do `null` (neošetřená) se výjimka šíří do hostitele.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-178">In these cases, the Result starts out non-null, and only if a custom exception handler explicitly sets it back to `null` (unhandled) will the exception propagate to the host.</span></span> <span data-ttu-id="ea3a9-179">Nastavení `Result` k `null` v takových případech může být užitečné pro dva scénáře:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-179">Setting `Result` to `null` in such cases can be useful for two scenarios:</span></span>

1. <span data-ttu-id="ea3a9-180">OWIN hostovaného webového rozhraní API s vlastní middleware zaregistrované před/mimo webového rozhraní API pro zpracování výjimek.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-180">OWIN hosted Web API with custom exception handling middleware registered before/outside Web API.</span></span>
2. <span data-ttu-id="ea3a9-181">Místní ladění prostřednictvím prohlížeče, kde žlutý obrazovky smrti je ve skutečnosti užitečné odpovědi k neošetřené výjimce.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-181">Local debugging via a browser, where the yellow screen of death is actually a helpful response for an unhandled exception.</span></span>

<span data-ttu-id="ea3a9-182">Pro protokolovačů výjimek a obslužné rutiny výjimek abychom nedělali nic k obnovení v případě stisknuté klávesy nebo samotná obslužná rutina vyvolá výjimku.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-182">For both exception loggers and exception handlers, we don't do anything to recover if the logger or handler itself throws an exception.</span></span> <span data-ttu-id="ea3a9-183">(Jiné než umožníte tím výjimce šíření, Odeslat názor v dolní části této stránky, pokud máte lepším řešením.) Kontrakt pro protokolovačů výjimek a obslužné rutiny je, že by neměla umožňují výjimky nešířily až po jejich volajícím; v opačném případě výjimka právě rozšíří, často až po hostitele, což vede k chybě HTML (například ASP. Žlutý obrazovky na NET) odesílaných zpět do klienta (což obvykle není upřednostňovanou možnost pro volání rozhraní API, které očekávají JSON nebo XML).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-183">(Other than letting the exception propagate, leave feedback at the bottom of this page if you have a better approach.) The contract for exception loggers and handlers is that they should not let exceptions propagate up to their callers; otherwise, the exception will just propagate, often all the way to the host resulting in an HTML error (like the ASP.NET's yellow screen) being sent back to the client (which usually isn't the preferred option for API callers that expect JSON or XML).</span></span>

## <a name="examples"></a><span data-ttu-id="ea3a9-184">Příklady</span><span class="sxs-lookup"><span data-stu-id="ea3a9-184">Examples</span></span>

### <a name="tracing-exception-logger"></a><span data-ttu-id="ea3a9-185">Protokolovač výjimek trasování</span><span class="sxs-lookup"><span data-stu-id="ea3a9-185">Tracing Exception Logger</span></span>

<span data-ttu-id="ea3a9-186">Protokolovač výjimek níže odesílání dat výjimek do nakonfigurovaného zdroje trasování (včetně v okně výstupu ladění v sadě Visual Studio).</span><span class="sxs-lookup"><span data-stu-id="ea3a9-186">The exception logger below send exception data to configured Trace sources (including the Debug output window in Visual Studio).</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample6.cs)]

### <a name="custom-error-message-exception-handler"></a><span data-ttu-id="ea3a9-187">Obslužná rutina výjimky vlastní chybové zprávy</span><span class="sxs-lookup"><span data-stu-id="ea3a9-187">Custom Error Message Exception Handler</span></span>

<span data-ttu-id="ea3a9-188">Následující níže vytvoří vlastní chybové odpovědi pro klienty, včetně e-mailovou adresu pro obrátíte na podporu.</span><span class="sxs-lookup"><span data-stu-id="ea3a9-188">The following below produces a custom error response to clients, including an email address for contacting support.</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample7.cs)]

## <a name="registering-exception-filters"></a><span data-ttu-id="ea3a9-189">Registrace filtry výjimek</span><span class="sxs-lookup"><span data-stu-id="ea3a9-189">Registering Exception Filters</span></span>

<span data-ttu-id="ea3a9-190">Pokud používáte šablonu projektu "Aplikace pro Web ASP.NET MVC 4" k vytvoření projektu, ukládejte kód webového rozhraní API konfigurace uvnitř `WebApiConfig` třídy v *aplikace/_spustit* složky:</span><span class="sxs-lookup"><span data-stu-id="ea3a9-190">If you use the "ASP.NET MVC 4 Web Application" project template to create your project, put your Web API configuration code inside the `WebApiConfig` class, in the *App/_Start* folder:</span></span>

[!code-csharp[Main](exception-handling/samples/sample7.cs?highlight=5)]

## <a name="appendix-base-class-details"></a><span data-ttu-id="ea3a9-191">Dodatek: Podrobností základní třídy</span><span class="sxs-lookup"><span data-stu-id="ea3a9-191">Appendix: Base Class Details</span></span>

[!code-csharp[Main](web-api-global-error-handling/samples/sample8.cs)]
