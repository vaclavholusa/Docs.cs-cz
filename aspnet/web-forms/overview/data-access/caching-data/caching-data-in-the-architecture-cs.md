---
uid: web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
title: Ukládání do mezipaměti dat v architektuře (C#) | Dokumentace Microsoftu
author: rick-anderson
description: V předchozím kurzu jsme zjistili, jak používat ukládání do mezipaměti v prezentační vrstvě. V tomto kurzu jsme zjistěte, jak využít výhod našich vrstvami architectu...
ms.author: riande
ms.date: 05/30/2007
ms.assetid: d29a7c41-0628-4a23-9dfc-bfea9c6c1054
msc.legacyurl: /web-forms/overview/data-access/caching-data/caching-data-in-the-architecture-cs
msc.type: authoredcontent
ms.openlocfilehash: 3971140aa7a6c829287e74df804694c19e34adcf
ms.sourcegitcommit: 45ac74e400f9f2b7dbded66297730f6f14a4eb25
ms.translationtype: MT
ms.contentlocale: cs-CZ
ms.lasthandoff: 08/16/2018
ms.locfileid: "41753678"
---
<a name="caching-data-in-the-architecture-c"></a><span data-ttu-id="31f7e-104">Ukládání dat do mezipaměti v architektuře (C#)</span><span class="sxs-lookup"><span data-stu-id="31f7e-104">Caching Data in the Architecture (C#)</span></span>
====================
<span data-ttu-id="31f7e-105">podle [Scott Meisnerová](https://twitter.com/ScottOnWriting)</span><span class="sxs-lookup"><span data-stu-id="31f7e-105">by [Scott Mitchell](https://twitter.com/ScottOnWriting)</span></span>

<span data-ttu-id="31f7e-106">[Stáhněte si ukázkovou aplikaci](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) nebo [stahovat PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span><span class="sxs-lookup"><span data-stu-id="31f7e-106">[Download Sample App](http://download.microsoft.com/download/4/a/7/4a7a3b18-d80e-4014-8e53-a6a2427f0d93/ASPNET_Data_Tutorial_59_CS.exe) or [Download PDF](caching-data-in-the-architecture-cs/_static/datatutorial59cs1.pdf)</span></span>

> <span data-ttu-id="31f7e-107">V předchozím kurzu jsme zjistili, jak používat ukládání do mezipaměti v prezentační vrstvě.</span><span class="sxs-lookup"><span data-stu-id="31f7e-107">In the previous tutorial we learned how to apply caching at the Presentation Layer.</span></span> <span data-ttu-id="31f7e-108">V tomto kurzu jsme zjistěte, jak využít výhod naší vrstvené architektury dat do mezipaměti na vrstvy obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-108">In this tutorial we learn how to take advantage of our layered architecture to cache data at the Business Logic Layer.</span></span> <span data-ttu-id="31f7e-109">Provedeme to rozšířením architektury zahrnout vrstvu ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-109">We do this by extending the architecture to include a Caching Layer.</span></span>


## <a name="introduction"></a><span data-ttu-id="31f7e-110">Úvod</span><span class="sxs-lookup"><span data-stu-id="31f7e-110">Introduction</span></span>

<span data-ttu-id="31f7e-111">Jak jsme viděli v předchozím kurzu, ukládání do mezipaměti dat prvku ObjectDataSource s je stejně jednoduché jako si několik vlastností.</span><span class="sxs-lookup"><span data-stu-id="31f7e-111">As we saw in the preceding tutorial, caching the ObjectDataSource s data is as simple as setting a couple of properties.</span></span> <span data-ttu-id="31f7e-112">Bohužel ObjectDataSource platí, ukládání do mezipaměti na prezentační vrstvu, která úzce spáruje zásad ukládání do mezipaměti na stránce ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="31f7e-112">Unfortunately, the ObjectDataSource applies caching at the Presentation Layer, which tightly couples the caching policies with the ASP.NET page.</span></span> <span data-ttu-id="31f7e-113">Jedním z důvodů pro vytváření vrstvené architektury je umožnit takové spojky je přerušeno.</span><span class="sxs-lookup"><span data-stu-id="31f7e-113">One of the reasons for creating a layered architecture is to allow such couplings to be broken.</span></span> <span data-ttu-id="31f7e-114">Vrstvy obchodní logiky, například odděluje obchodní logiku ze stránek ASP.NET, zatímco vrstva přístupu k datům odděluje obě části Podrobnosti o přístupu dat.</span><span class="sxs-lookup"><span data-stu-id="31f7e-114">The Business Logic Layer, for instance, decouples the business logic from the ASP.NET pages, while the Data Access Layer decouples the data access details.</span></span> <span data-ttu-id="31f7e-115">Díky tomuto oddělení podrobnosti o přístupu obchodní logiku a data totiž upřednostňované, v části systému umožňuje lépe čitelný, snadněji spravovatelné a flexibilnější, chcete-li změnit.</span><span class="sxs-lookup"><span data-stu-id="31f7e-115">This decoupling of business logic and data access details is preferred, in part, because it makes the system more readable, more maintainable, and more flexible to change.</span></span> <span data-ttu-id="31f7e-116">Také umožňuje znalosti domény a rozdělení práce, vývojář, pracující na t kódu prezentační vrstva musí být obeznámeni s podrobnostmi o databázi s aby bylo možné její práci.</span><span class="sxs-lookup"><span data-stu-id="31f7e-116">It also allows for domain knowledge and division of labor a developer working on the Presentation Layer doesn t need to be familiar with the database s details in order to do her job.</span></span> <span data-ttu-id="31f7e-117">Zásady ukládání do mezipaměti od prezentační vrstvy oddělení nabízí podobné výhody.</span><span class="sxs-lookup"><span data-stu-id="31f7e-117">Decoupling the caching policy from the Presentation Layer offers similar benefits.</span></span>

<span data-ttu-id="31f7e-118">V tomto kurzu jsme se rozšířit Naše architektura zahrnout *vrstev ukládání do mezipaměti* (nebo CL zkráceně), který využívá naše zásady ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-118">In this tutorial we will augment our architecture to include a *Caching Layer* (or CL for short) that employs our caching policy.</span></span> <span data-ttu-id="31f7e-119">Bude obsahovat vrstev ukládání do mezipaměti `ProductsCL` třída, která poskytuje přístup k informacím o produktu pomocí metody, jako je `GetProducts()`, `GetProductsByCategoryID(categoryID)`a tak dále, že při vyvolání, bude první pokus o načtení dat z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-119">The Caching Layer will include a `ProductsCL` class that provides access to product information with methods like `GetProducts()`, `GetProductsByCategoryID(categoryID)`, and so forth, that, when invoked, will first attempt to retrieve the data from the cache.</span></span> <span data-ttu-id="31f7e-120">Pokud do mezipaměti je prázdný, tyto metody vyvolá odpovídající `ProductsBLL` metoda ve BLL, který by pak získat data z vrstvy DAL.</span><span class="sxs-lookup"><span data-stu-id="31f7e-120">If the cache is empty, these methods will invoke the appropriate `ProductsBLL` method in the BLL, which would in turn get the data from the DAL.</span></span> <span data-ttu-id="31f7e-121">`ProductsCL` Metody mezipaměti dat načtených z BLL před jeho vrácením.</span><span class="sxs-lookup"><span data-stu-id="31f7e-121">The `ProductsCL` methods cache the data retrieved from the BLL before returning it.</span></span>

<span data-ttu-id="31f7e-122">Jak ukazuje obrázek 1, je umístěn CL mezi prezentační a obchodní logiky vrstvy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-122">As Figure 1 shows, the CL resides between the Presentation and Business Logic Layers.</span></span>


![Další vrstva v architektuře náš je vrstev ukládání do mezipaměti (CL)](caching-data-in-the-architecture-cs/_static/image1.png)

<span data-ttu-id="31f7e-124">**Obrázek 1**: ukládání do mezipaměti vrstvy (+/ CL) je další vrstva v architektuře náš</span><span class="sxs-lookup"><span data-stu-id="31f7e-124">**Figure 1**: The Caching Layer (CL) is Another Layer in Our Architecture</span></span>


## <a name="step-1-creating-the-caching-layer-classes"></a><span data-ttu-id="31f7e-125">Krok 1: Vytvoření třídy vrstev ukládání do mezipaměti</span><span class="sxs-lookup"><span data-stu-id="31f7e-125">Step 1: Creating the Caching Layer Classes</span></span>

<span data-ttu-id="31f7e-126">V tomto kurzu vytvoříme velmi jednoduchý CL s jednu třídu `ProductsCL` , který má pouze několik metod.</span><span class="sxs-lookup"><span data-stu-id="31f7e-126">In this tutorial we will create a very simple CL with a single class `ProductsCL` that has only a handful of methods.</span></span> <span data-ttu-id="31f7e-127">Vytváření vrstvu dokončeno ukládání do mezipaměti pro celou aplikaci by vyžadovaly vytvoření `CategoriesCL`, `EmployeesCL`, a `SuppliersCL` třídy a nabízí metody v těchto tříd vrstev ukládání do mezipaměti pro každou metodu dat přístup nebo změna v BLL.</span><span class="sxs-lookup"><span data-stu-id="31f7e-127">Building a complete Caching Layer for the entire application would require creating `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes, and providing a method in these Caching Layer classes for each data access or modification method in the BLL.</span></span> <span data-ttu-id="31f7e-128">Stejně jako u knihoven BLL a DAL, by měla být v ideálním případě implementována vrstev ukládání do mezipaměti jako samostatný projekt knihovny tříd; ale jsme provede jako třída v `App_Code` složky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-128">As with the BLL and DAL, the Caching Layer should ideally be implemented as a separate Class Library project; however, we will implement it as a class in the `App_Code` folder.</span></span>

<span data-ttu-id="31f7e-129">Na další samostatné čistě CL třídy z třídy DAL a BLL umožňují s vytvořit novou podsložku v `App_Code` složky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-129">To more cleanly separate the CL classes from the DAL and BLL classes, let s create a new subfolder in the `App_Code` folder.</span></span> <span data-ttu-id="31f7e-130">Klikněte pravým tlačítkem na `App_Code` složku v Průzkumníku řešení zvolte novou složku a pojmenujte novou složku `CL`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-130">Right-click on the `App_Code` folder in the Solution Explorer, choose New Folder, and name the new folder `CL`.</span></span> <span data-ttu-id="31f7e-131">Po vytvoření této složky, přidejte do ní novou třídu s názvem `ProductsCL.cs`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-131">After creating this folder, add to it a new class named `ProductsCL.cs`.</span></span>


![Přidat novou složku s názvem CL a třídu s názvem ProductsCL.cs](caching-data-in-the-architecture-cs/_static/image2.png)

<span data-ttu-id="31f7e-133">**Obrázek 2**: Přidat novou složku s názvem `CL` a třídu s názvem `ProductsCL.cs`</span><span class="sxs-lookup"><span data-stu-id="31f7e-133">**Figure 2**: Add a New Folder Named `CL` and a Class Named `ProductsCL.cs`</span></span>


<span data-ttu-id="31f7e-134">`ProductsCL` Třída by měla obsahovat stejnou sadu dat přístup a úpravy metod, jak se nachází ve své třídě odpovídající vrstvy obchodní logiky (`ProductsBLL`).</span><span class="sxs-lookup"><span data-stu-id="31f7e-134">The `ProductsCL` class should include the same set of data access and modification methods as found in its corresponding Business Logic Layer class (`ProductsBLL`).</span></span> <span data-ttu-id="31f7e-135">Místo vytváření všechny tyto metody umožňují s pouze sestavení používá několik tady získat představu pro tyto vzory se dají CL.</span><span class="sxs-lookup"><span data-stu-id="31f7e-135">Rather than creating all of these methods, let s just build a couple here to get a feel for the patterns used by the CL.</span></span> <span data-ttu-id="31f7e-136">Zejména, přidáme `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody v kroku 3 a `UpdateProduct` přetížení v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="31f7e-136">In particular, we'll add the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods in Step 3 and an `UpdateProduct` overload in Step 4.</span></span> <span data-ttu-id="31f7e-137">Můžete přidat zbývající `ProductsCL` metody a `CategoriesCL`, `EmployeesCL`, a `SuppliersCL` třídy ve volném čase.</span><span class="sxs-lookup"><span data-stu-id="31f7e-137">You can add the remaining `ProductsCL` methods and `CategoriesCL`, `EmployeesCL`, and `SuppliersCL` classes at your leisure.</span></span>

## <a name="step-2-reading-and-writing-to-the-data-cache"></a><span data-ttu-id="31f7e-138">Krok 2: Čtení a zápis do mezipaměti dat</span><span class="sxs-lookup"><span data-stu-id="31f7e-138">Step 2: Reading and Writing to the Data Cache</span></span>

<span data-ttu-id="31f7e-139">ObjectDataSource ukládání do mezipaměti funkce prozkoumali v předchozím kurzu interně používá k ukládání dat načtených z BLL datové mezipaměti technologie ASP.NET.</span><span class="sxs-lookup"><span data-stu-id="31f7e-139">The ObjectDataSource caching feature explored in the preceding tutorial internally uses the ASP.NET data cache to store the data retrieved from the BLL.</span></span> <span data-ttu-id="31f7e-140">Mezipaměť dat je také možné programově přistupovat z třídy modelu code-behind stránky technologie ASP.NET nebo ze tříd v architektuře s webovou aplikací.</span><span class="sxs-lookup"><span data-stu-id="31f7e-140">The data cache can also be accessed programmatically from ASP.NET pages code-behind classes or from the classes in the web application s architecture.</span></span> <span data-ttu-id="31f7e-141">Ke čtení a zápis do mezipaměti dat z modelu code-behind třídy s stránky technologie ASP.NET, používají následující vzor:</span><span class="sxs-lookup"><span data-stu-id="31f7e-141">To read and write to the data cache from an ASP.NET page s code-behind class, use the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample1.cs)]

<span data-ttu-id="31f7e-142">[ `Cache` Třídy](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [ `Insert` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) má několik přetížení.</span><span class="sxs-lookup"><span data-stu-id="31f7e-142">The [`Cache` class](https://msdn.microsoft.com/library/system.web.caching.cache.aspx) s [`Insert` method](https://msdn.microsoft.com/library/system.web.caching.cache.insert.aspx) has a number of overloads.</span></span> <span data-ttu-id="31f7e-143">`Cache["key"] = value` a `Cache.Insert(key, value)` je synonymní a jak přidat položku do mezipaměti pomocí zadaného klíče bez definované vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-143">`Cache["key"] = value` and `Cache.Insert(key, value)` are synonymous and both add an item to the cache using the specified key without a defined expiry.</span></span> <span data-ttu-id="31f7e-144">Obvykle chcete zadat vypršení platnosti při přidání položky do mezipaměti, buď jako závislosti nebo vypršení platnosti časovou synchronizací.</span><span class="sxs-lookup"><span data-stu-id="31f7e-144">Typically, we want to specify an expiry when adding an item to the cache, either as a dependency, a time-based expiry, or both.</span></span> <span data-ttu-id="31f7e-145">Pomocí jednoho z jiných `Insert` přetížení metody s k poskytnutí informací podle závislostí nebo času vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-145">Use one of the other `Insert` method s overloads to provide dependency- or time-based expiry information.</span></span>

<span data-ttu-id="31f7e-146">Ukládání do mezipaměti vrstvu, kterou metod s muset nejdřív zkontrolujte, zda je požadovaná data v mezipaměti a pokud ano, vrátí ho odtud.</span><span class="sxs-lookup"><span data-stu-id="31f7e-146">The Caching Layer s methods need to first check if the requested data is in the cache and, if so, return it from there.</span></span> <span data-ttu-id="31f7e-147">Pokud není požadovaná data v mezipaměti, odpovídající metodu BLL musí vyvolat.</span><span class="sxs-lookup"><span data-stu-id="31f7e-147">If the requested data is not in the cache, the appropriate BLL method needs to be invoked.</span></span> <span data-ttu-id="31f7e-148">Vrácená hodnota by měla uložit do mezipaměti a vráceny, jak ukazuje následující sekvenční diagram.</span><span class="sxs-lookup"><span data-stu-id="31f7e-148">Its return value should be cached and then returned, as the following sequence diagram illustrates.</span></span>


![Metody s vrstev ukládání do mezipaměti vrátit Data z mezipaměti, pokud je k dispozici s](caching-data-in-the-architecture-cs/_static/image3.png)

<span data-ttu-id="31f7e-150">**Obrázek 3**: metod The vrstev ukládání do mezipaměti s vrátit Data z mezipaměti, pokud je k dispozici s</span><span class="sxs-lookup"><span data-stu-id="31f7e-150">**Figure 3**: The Caching Layer s Methods Return Data from the Cache if it s Available</span></span>


<span data-ttu-id="31f7e-151">Posloupnost znázorněno na obrázku 3 je provést v CL třídy pomocí následujícího vzorce:</span><span class="sxs-lookup"><span data-stu-id="31f7e-151">The sequence depicted in Figure 3 is accomplished in the CL classes using the following pattern:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample2.cs)]

<span data-ttu-id="31f7e-152">Tady *typ* je typ dat uložené v mezipaměti `Northwind.ProductsDataTable`, například *klíč* je klíč, který jednoznačně identifikuje položku mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-152">Here, *Type* is the type of data being stored in the cache `Northwind.ProductsDataTable`, for example while *key* is the key that uniquely identifies the cache item.</span></span> <span data-ttu-id="31f7e-153">Pokud položka se zadaným *klíč* není v mezipaměti, pak *instance* bude `null` a data budou načteny z příslušné metody knihoven BLL a přidají se do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-153">If the item with the specified *key* is not in the cache, then *instance* will be `null` and the data will be retrieved from the appropriate BLL method and added to the cache.</span></span> <span data-ttu-id="31f7e-154">Době `return instance` dosažení *instance* obsahuje odkaz na data, buď z mezipaměti nebo získaných z BLL.</span><span class="sxs-lookup"><span data-stu-id="31f7e-154">By the time `return instance` is reached, *instance* contains a reference to the data, either from the cache or pulled from the BLL.</span></span>

<span data-ttu-id="31f7e-155">Ujistěte se, že výše uvedené model použijte při přístupu k datům z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-155">Be sure to use the above pattern when accessing data from the cache.</span></span> <span data-ttu-id="31f7e-156">Následující vzor, který vypadá na první pohled ekvivalentní, obsahuje malý rozdíl, který představuje časování.</span><span class="sxs-lookup"><span data-stu-id="31f7e-156">The following pattern, which, at first glance, looks equivalent, contains a subtle difference that introduces a race condition.</span></span> <span data-ttu-id="31f7e-157">Ke konfliktům časování je obtížné ladit, protože samotné odhalit nedojde a je obtížné reprodukovat.</span><span class="sxs-lookup"><span data-stu-id="31f7e-157">Race conditions are difficult to debug because they reveal themselves sporadically and are difficult to reproduce.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample3.cs)]

<span data-ttu-id="31f7e-158">Rozdíl v této druhé nesprávný kód fragmentu kódu je, že místo uložení odkazu na položku z mezipaměti v místní proměnné, datové mezipaměti přistupuje přímo v podmíněném příkazu *a* v `return`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-158">The difference in this second, incorrect code snippet is that rather than storing a reference to the cached item in a local variable, the data cache is accessed directly in the conditional statement *and* in the `return`.</span></span> <span data-ttu-id="31f7e-159">Představte si, že po dosažení tohoto kódu `Cache["key"]` jinou hodnotu než`null`, ale předtím, než `return` je dosažen příkaz, vyloučí systému *klíč* z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-159">Imagine that when this code is reached, `Cache["key"]` is non-`null`, but before the `return` statement is reached, the system evicts *key* from the cache.</span></span> <span data-ttu-id="31f7e-160">V tomto případě výjimečných kód vrátí `null` hodnotu namísto očekávaného typu objektu.</span><span class="sxs-lookup"><span data-stu-id="31f7e-160">In this rare case, the code will return a `null` value rather than an object of the expected type.</span></span>

> [!NOTE]
> <span data-ttu-id="31f7e-161">Mezipaměť dat je bezpečná pro vlákno, takže nejsou potřeba t synchronizaci přístupu vláken pro jednoduché operace čtení nebo zápisu.</span><span class="sxs-lookup"><span data-stu-id="31f7e-161">The data cache is thread-safe, so you don t need to synchronize thread access for simple reads or writes.</span></span> <span data-ttu-id="31f7e-162">Ale pokud potřebujete provést více operací s daty v mezipaměti, která musí být Atomický, zodpovídáte za implementaci zámek nebo jiný mechanismus zajistit bezpečný přístup z více vláken.</span><span class="sxs-lookup"><span data-stu-id="31f7e-162">However, if you need to perform multiple operations on data in the cache that need to be atomic, you are responsible for implementing a lock or some other mechanism to ensure thread safety.</span></span> <span data-ttu-id="31f7e-163">Zobrazit [synchronizaci přístupu k mezipaměti ASP.NET](http://www.ddj.com/184406369) Další informace.</span><span class="sxs-lookup"><span data-stu-id="31f7e-163">See [Synchronizing Access to the ASP.NET Cache](http://www.ddj.com/184406369) for more information.</span></span>


<span data-ttu-id="31f7e-164">Položky můžete programově vyřazen z mezipaměti data s využitím [ `Remove` metoda](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) takto:</span><span class="sxs-lookup"><span data-stu-id="31f7e-164">An item can be programmatically evicted from the data cache using the [`Remove` method](https://msdn.microsoft.com/library/system.web.caching.cache.remove.aspx) like so:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample4.cs)]

## <a name="step-3-returning-product-information-from-theproductsclclass"></a><span data-ttu-id="31f7e-165">Krok 3: Vrací informace o produktu z`ProductsCL`třídy</span><span class="sxs-lookup"><span data-stu-id="31f7e-165">Step 3: Returning Product Information from the`ProductsCL`Class</span></span>

<span data-ttu-id="31f7e-166">Pro tento kurz umožní s implementovat dvě metody pro vracení informací o produktu ze `ProductsCL` třídy: `GetProducts()` a `GetProductsByCategoryID(categoryID)`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-166">For this tutorial let s implement two methods for returning product information from the `ProductsCL` class: `GetProducts()` and `GetProductsByCategoryID(categoryID)`.</span></span> <span data-ttu-id="31f7e-167">Jak je `ProductsBL` třídy v vrstvy obchodní logiky `GetProducts()` metodu CL vrátí informace o všech produktů, jako `Northwind.ProductsDataTable` objektu, při `GetProductsByCategoryID(categoryID)` vrátí všechny produkty v zadané kategorii.</span><span class="sxs-lookup"><span data-stu-id="31f7e-167">Like with the `ProductsBL` class in the Business Logic Layer, the `GetProducts()` method in the CL returns information about all of the products as a `Northwind.ProductsDataTable` object, while `GetProductsByCategoryID(categoryID)` returns all of the products from a specified category.</span></span>

<span data-ttu-id="31f7e-168">Následující kód ukazuje část metody v `ProductsCL` třídy:</span><span class="sxs-lookup"><span data-stu-id="31f7e-168">The following code shows a portion of the methods in the `ProductsCL` class:</span></span>


[!code-vb[Main](caching-data-in-the-architecture-cs/samples/sample5.vb)]

<span data-ttu-id="31f7e-169">Nejprve, Všimněte si, `DataObject` a `DataObjectMethodAttribute` atributy použité na třídy a metody.</span><span class="sxs-lookup"><span data-stu-id="31f7e-169">First, note the `DataObject` and `DataObjectMethodAttribute` attributes applied to the class and methods.</span></span> <span data-ttu-id="31f7e-170">Tyto atributy poskytují informace k Průvodci s prvek ObjectDataSource, označující, co třídy a metody by se zobrazit v Průvodci s kroky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-170">These attributes provide information to the ObjectDataSource s wizard, indicating what classes and methods should appear in the wizard s steps.</span></span> <span data-ttu-id="31f7e-171">Protože CL třídy a metody bude přistupovat prvku ObjectDataSource v prezentační vrstvě, po přidání těchto atributů a zlepšit tak prostředí v době návrhu.</span><span class="sxs-lookup"><span data-stu-id="31f7e-171">Since the CL classes and methods will be accessed from an ObjectDataSource in the Presentation Layer, I added these attributes to enhance the design-time experience.</span></span> <span data-ttu-id="31f7e-172">Vraťte se do [vytvoření vrstvy obchodní logiky](../introduction/creating-a-business-logic-layer-cs.md) kurz pro důkladnější popis těchto atributů a jejich vliv.</span><span class="sxs-lookup"><span data-stu-id="31f7e-172">Refer back to the [Creating a Business Logic Layer](../introduction/creating-a-business-logic-layer-cs.md) tutorial for a more thorough description on these attributes and their effects.</span></span>

<span data-ttu-id="31f7e-173">V `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody, že data vrácená z `GetCacheItem(key)` metoda je přiřazena k místní proměnné.</span><span class="sxs-lookup"><span data-stu-id="31f7e-173">In the `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods, the data returned from the `GetCacheItem(key)` method is assigned to a local variable.</span></span> <span data-ttu-id="31f7e-174">`GetCacheItem(key)` Metodu, která prozkoumáme krátce, vrátí určité položky z mezipaměti stanoveného *klíč*.</span><span class="sxs-lookup"><span data-stu-id="31f7e-174">The `GetCacheItem(key)` method, which we'll examine shortly, returns a particular item from the cache based on the specified *key*.</span></span> <span data-ttu-id="31f7e-175">Pokud žádná taková data nenajde v mezipaměti, je načten z odpovídající `ProductsBLL` metoda třídy a pak přidá do mezipaměti pomocí `AddCacheItem(key, value)` metody.</span><span class="sxs-lookup"><span data-stu-id="31f7e-175">If no such data is found in cache, it is retrieved from the corresponding `ProductsBLL` class method and then added to the cache using the `AddCacheItem(key, value)` method.</span></span>

<span data-ttu-id="31f7e-176">`GetCacheItem(key)` a `AddCacheItem(key, value)` metody rozhraní se mezipaměť dat, čtení a zápis hodnot, v uvedeném pořadí.</span><span class="sxs-lookup"><span data-stu-id="31f7e-176">The `GetCacheItem(key)` and `AddCacheItem(key, value)` methods interface with the data cache, reading and writing values, respectively.</span></span> <span data-ttu-id="31f7e-177">`GetCacheItem(key)` Metoda je jednodušší z nich.</span><span class="sxs-lookup"><span data-stu-id="31f7e-177">The `GetCacheItem(key)` method is the simpler of the two.</span></span> <span data-ttu-id="31f7e-178">Jednoduše vrací hodnotu z mezipaměti třídy pomocí předaným *klíč*:</span><span class="sxs-lookup"><span data-stu-id="31f7e-178">It simply returns the value from the Cache class using the passed-in *key*:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample6.cs)]

<span data-ttu-id="31f7e-179">`GetCacheItem(key)` nepoužívá *klíč* hodnota zadána, ale místo toho volání `GetCacheKey(key)` metoda, která vrátí *klíč* předponou ProductsCache-.</span><span class="sxs-lookup"><span data-stu-id="31f7e-179">`GetCacheItem(key)` does not use *key* value as supplied, but instead calls the `GetCacheKey(key)` method, which returns the *key* prepended with ProductsCache-.</span></span> <span data-ttu-id="31f7e-180">`MasterCacheKeyArray`, Který obsahuje řetězec ProductsCache, také používá `AddCacheItem(key, value)` způsob, jak uvidíme okamžik.</span><span class="sxs-lookup"><span data-stu-id="31f7e-180">The `MasterCacheKeyArray`, which holds the string ProductsCache, is also used by the `AddCacheItem(key, value)` method, as we'll see momentarily.</span></span>

<span data-ttu-id="31f7e-181">Z třídy modelu code-behind stránky s ASP.NET, mezipaměť dat lze přistupovat pomocí `Page` třída s [ `Cache` vlastnost](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx)a umožňuje syntaxí `Cache["key"] = value`, jak je popsáno v kroku 2.</span><span class="sxs-lookup"><span data-stu-id="31f7e-181">From an ASP.NET page s code-behind class, the data cache can be accessed using the `Page` class s [`Cache` property](https://msdn.microsoft.com/library/system.web.ui.page.cache.aspx), and allows for syntax like `Cache["key"] = value`, as discussed in Step 2.</span></span> <span data-ttu-id="31f7e-182">Ze třídy v rámci architektury mezipaměti dat lze přistupovat pomocí buď `HttpRuntime.Cache` nebo `HttpContext.Current.Cache`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-182">From a class within the architecture, the data cache can be accessed using either `HttpRuntime.Cache` or `HttpContext.Current.Cache`.</span></span> <span data-ttu-id="31f7e-183">[Petr Johnsonem](https://weblogs.asp.net/pjohnson/default.aspx)na blogu [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) poznámky výhod snížený výkon při použití `HttpRuntime` místo `HttpContext.Current`; v důsledku toho `ProductsCL` používá `HttpRuntime`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-183">[Peter Johnson](https://weblogs.asp.net/pjohnson/default.aspx)'s blog entry [HttpRuntime.Cache vs. HttpContext.Current.Cache](https://weblogs.asp.net/pjohnson/httpruntime-cache-vs-httpcontext-current-cache) notes the slight performance advantage in using `HttpRuntime` instead of `HttpContext.Current`; consequently, `ProductsCL` uses `HttpRuntime`.</span></span>

> [!NOTE]
> <span data-ttu-id="31f7e-184">Pokud vaše architektura je implementováno pomocí projekty knihovny tříd, budete muset přidat odkaz na `System.Web` sestavení, aby bylo možné používat [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) a [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) třídy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-184">If your architecture is implemented using Class Library projects then you will need to add a reference to the `System.Web` assembly in order to use the [HttpRuntime](https://msdn.microsoft.com/library/system.web.httpruntime.aspx) and [HttpContext](https://msdn.microsoft.com/library/system.web.httpcontext.aspx) classes.</span></span>


<span data-ttu-id="31f7e-185">Pokud položka není nalezena v mezipaměti, `ProductsCL` metody třídy s získat data z knihoven BLL a přidejte ji do mezipaměti pomocí `AddCacheItem(key, value)` metoda.</span><span class="sxs-lookup"><span data-stu-id="31f7e-185">If the item is not found in the cache, the `ProductsCL` class s methods get the data from the BLL and add it to the cache using the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="31f7e-186">Chcete-li přidat *hodnotu* do mezipaměti můžeme použít následující kód, který používá 60 druhé čas vypršení:</span><span class="sxs-lookup"><span data-stu-id="31f7e-186">To add *value* to the cache we could use the following code, which uses a 60 second time expiry:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample7.cs)]

<span data-ttu-id="31f7e-187">`DateTime.Now.AddSeconds(CacheDuration)` Určuje podle času vypršení platnosti budoucí dobu 60 sekund [ `System.Web.Caching.Cache.NoSlidingExpiration` ](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) označuje tom, že s žádné klouzavé vypršení platnosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-187">`DateTime.Now.AddSeconds(CacheDuration)` specifies the time-based expiry 60 seconds in the future while [`System.Web.Caching.Cache.NoSlidingExpiration`](https://msdn.microsoft.com/library/system.web.caching.cache.noslidingexpiration(vs.80).aspx) indicates that there s no sliding expiration.</span></span> <span data-ttu-id="31f7e-188">Když je tento `Insert` přetížení metody obsahuje vstupní parametry pro obě absolutní a klouzavé vypršení platnosti, můžete pouze zadat jeden z nich.</span><span class="sxs-lookup"><span data-stu-id="31f7e-188">While this `Insert` method overload has input parameters for both an absolute and sliding expiry, you can only provide one of the two.</span></span> <span data-ttu-id="31f7e-189">Pokud se pokusíte k určení absolutní čas a časové období `Insert` vyvolá metoda výjimku `ArgumentException` výjimky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-189">If you attempt to specify both an absolute time and a time span, the `Insert` method will throw an `ArgumentException` exception.</span></span>

> [!NOTE]
> <span data-ttu-id="31f7e-190">Tato implementace `AddCacheItem(key, value)` metoda aktuálně má některé nedostatky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-190">This implementation of the `AddCacheItem(key, value)` method currently has some shortcomings.</span></span> <span data-ttu-id="31f7e-191">Vytvoříme řešení a vyřešit tyto problémy v kroku 4.</span><span class="sxs-lookup"><span data-stu-id="31f7e-191">We'll address and overcome these issues in Step 4.</span></span>


## <a name="step-4-invalidating-the-cache-when-the-data-is-modified-through-the-architecture"></a><span data-ttu-id="31f7e-192">Krok 4: Zrušení platnosti při the Data v mezipaměti je upravovat prostřednictvím the architektury</span><span class="sxs-lookup"><span data-stu-id="31f7e-192">Step 4: Invalidating the Cache When the Data is Modified Through the Architecture</span></span>

<span data-ttu-id="31f7e-193">Spolu s metod načítání dat je potřeba poskytovat stejné metody, jako BLL pro vkládání, aktualizaci a odstraňování dat vrstev ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-193">Along with data retrieval methods, the Caching Layer needs to provide the same methods as the BLL for inserting, updating, and deleting data.</span></span> <span data-ttu-id="31f7e-194">Metody CL data s úpravy neprovádějte žádné změny data uložená v mezipaměti, ale místo toho volat metodu BLL s odpovídající data změny a pak zneplatnění mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-194">The CL s data modification methods do not modify the cached data, but rather call the BLL s corresponding data modification method and then invalidate the cache.</span></span> <span data-ttu-id="31f7e-195">Jak jsme viděli v předchozím kurzu, to je stejné chování, která se použije prvku ObjectDataSource při jeho ukládání do mezipaměti funkce jsou povolené a jeho `Insert`, `Update`, nebo `Delete` jsou metody vyvolány.</span><span class="sxs-lookup"><span data-stu-id="31f7e-195">As we saw in the preceding tutorial, this is the same behavior that the ObjectDataSource applies when its caching features are enabled and its `Insert`, `Update`, or `Delete` methods are invoked.</span></span>

<span data-ttu-id="31f7e-196">Následující `UpdateProduct` přetížení, ukazuje, jak implementovat metody změny dat CL:</span><span class="sxs-lookup"><span data-stu-id="31f7e-196">The following `UpdateProduct` overload illustrates how to implement the data modification methods in the CL:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample8.cs)]

<span data-ttu-id="31f7e-197">Úprava dat odpovídající metoda vrstvy obchodní logiky je vyvolán, ale před vrácením odpovědi musíme zneplatnění mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-197">The appropriate data modification Business Logic Layer method is invoked, but before its response is returned we need to invalidate the cache.</span></span> <span data-ttu-id="31f7e-198">Bohužel zrušení platnosti mezipaměti není jednoznačné protože `ProductsCL` třída s `GetProducts()` a `GetProductsByCategoryID(categoryID)` metody každé přidání položek do mezipaměti s různými klíči a `GetProductsByCategoryID(categoryID)` metoda přidá položku různé mezipaměti pro každý jedinečný *categoryID*.</span><span class="sxs-lookup"><span data-stu-id="31f7e-198">Unfortunately, invalidating the cache is not straightforward because the `ProductsCL` class s `GetProducts()` and `GetProductsByCategoryID(categoryID)` methods each add items to the cache with different keys, and the `GetProductsByCategoryID(categoryID)` method adds a different cache item for each unique *categoryID*.</span></span>

<span data-ttu-id="31f7e-199">Při zrušení platnosti mezipaměti, budeme muset odebrat *všechny* položek, které byly přidány pomocí `ProductsCL` třídy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-199">When invalidating the cache, we need to remove *all* of the items that may have been added by the `ProductsCL` class.</span></span> <span data-ttu-id="31f7e-200">Toho můžete docílit tím, že přidružíte *závislosti mezipaměti* s každou položku Přidat do mezipaměti `AddCacheItem(key, value)` metoda.</span><span class="sxs-lookup"><span data-stu-id="31f7e-200">This can be accomplished by associating a *cache dependency* with the each item added to the cache in the `AddCacheItem(key, value)` method.</span></span> <span data-ttu-id="31f7e-201">Obecně platí závislost mezipaměti může být jiná položka v mezipaměti, souboru v systému souborů nebo data z databáze Microsoft SQL Server.</span><span class="sxs-lookup"><span data-stu-id="31f7e-201">In general, a cache dependency can be another item in the cache, a file on the file system, or data from a Microsoft SQL Server database.</span></span> <span data-ttu-id="31f7e-202">Když závislost změní nebo je odebrat z mezipaměti, položky v mezipaměti je spojený se automaticky vyřadí z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-202">When the dependency changes or is removed from the cache, the cache items it is associated with are automatically evicted from the cache.</span></span> <span data-ttu-id="31f7e-203">Pro účely tohoto kurzu chceme vytvořit další položky v mezipaměti, která slouží jako závislost mezipaměti pro všechny položky přidané prostřednictvím `ProductsCL` třídy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-203">For this tutorial, we want to create an additional item in the cache that serves as a cache dependency for all items added through the `ProductsCL` class.</span></span> <span data-ttu-id="31f7e-204">Tímto způsobem všechny tyto položky lze odebrat z mezipaměti jednoduše odebráním závislosti mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-204">That way, all of these items can be removed from the cache by simply removing the cache dependency.</span></span>

<span data-ttu-id="31f7e-205">Umožněte s aktualizace `AddCacheItem(key, value)` tak, aby každá položka přidána do mezipaměti prostřednictvím této metody není přidružená metoda závislost jedné mezipaměti:</span><span class="sxs-lookup"><span data-stu-id="31f7e-205">Let s update the `AddCacheItem(key, value)` method so that each item added to the cache through this method is associated with a single cache dependency:</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample9.cs)]

<span data-ttu-id="31f7e-206">`MasterCacheKeyArray` je pole řetězců obsahující jednu hodnotu, ProductsCache.</span><span class="sxs-lookup"><span data-stu-id="31f7e-206">`MasterCacheKeyArray` is a string array that holds a single value, ProductsCache.</span></span> <span data-ttu-id="31f7e-207">Položka mezipaměti je nejprve přidány do mezipaměti a přiřazené aktuálnímu datu a času.</span><span class="sxs-lookup"><span data-stu-id="31f7e-207">First, a cache item is added to the cache and assigned the current date and time.</span></span> <span data-ttu-id="31f7e-208">Pokud položka mezipaměti už existuje, se aktualizuje.</span><span class="sxs-lookup"><span data-stu-id="31f7e-208">If the cache item already exists, it is updated.</span></span> <span data-ttu-id="31f7e-209">V dalším kroku se vytvoří závislost mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-209">Next, a cache dependency is created.</span></span> <span data-ttu-id="31f7e-210">[ `CacheDependency` Třídy](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) konstruktor s má několik přetížení, ale použitému v tady očekává, že dvě `string` pole vstupy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-210">The [`CacheDependency` class](https://msdn.microsoft.com/library/system.web.caching.cachedependency(VS.80).aspx) s constructor has a number of overloads, but the one being used in here expects two `string` array inputs.</span></span> <span data-ttu-id="31f7e-211">První z nich určuje sadu souborů pro použití jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-211">The first one specifies the set of files to be used as dependencies.</span></span> <span data-ttu-id="31f7e-212">Protože jsme zadávat t chcete použít libovolné souborové závislosti, hodnota `null` se používá pro první vstupní parametr.</span><span class="sxs-lookup"><span data-stu-id="31f7e-212">Since we don t want to use any file-based dependencies, a value of `null` is used for the first input parameter.</span></span> <span data-ttu-id="31f7e-213">Druhé vstupní parametr určuje sadu mezipaměti klíče, které slouží jako závislosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-213">The second input parameter specifies the set of cache keys to use as dependencies.</span></span> <span data-ttu-id="31f7e-214">Tady můžeme určit jednu závislost, `MasterCacheKeyArray`.</span><span class="sxs-lookup"><span data-stu-id="31f7e-214">Here we specify our single dependency, `MasterCacheKeyArray`.</span></span> <span data-ttu-id="31f7e-215">`CacheDependency` Je pak předán `Insert` metody.</span><span class="sxs-lookup"><span data-stu-id="31f7e-215">The `CacheDependency` is then passed into the `Insert` method.</span></span>

<span data-ttu-id="31f7e-216">Pomocí této změny `AddCacheItem(key, value)`, invaliding mezipaměť je stejně jednoduché jako odebráním závislosti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-216">With this modification to `AddCacheItem(key, value)`, invaliding the cache is as simple as removing the dependency.</span></span>


[!code-csharp[Main](caching-data-in-the-architecture-cs/samples/sample10.cs)]

## <a name="step-5-calling-the-caching-layer-from-the-presentation-layer"></a><span data-ttu-id="31f7e-217">Krok 5: Volání ukládání do mezipaměti vrstvy od prezentační vrstvy</span><span class="sxs-lookup"><span data-stu-id="31f7e-217">Step 5: Calling the Caching Layer from the Presentation Layer</span></span>

<span data-ttu-id="31f7e-218">Ukládání do mezipaměti vrstvu s třídy a metody je možné pracovat s daty pomocí technik jsme ve prozkoumat v rámci těchto kurzů.</span><span class="sxs-lookup"><span data-stu-id="31f7e-218">The Caching Layer s classes and methods can be used to work with data using the techniques we ve examined throughout these tutorials.</span></span> <span data-ttu-id="31f7e-219">Pro ilustraci, práci s daty v mezipaměti, uložte změny do souboru `ProductsCL` třídy a pak otevřete `FromTheArchitecture.aspx` stránku `Caching` složky a přidejte prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="31f7e-219">To illustrate working with cached data, save your changes to the `ProductsCL` class and then open the `FromTheArchitecture.aspx` page in the `Caching` folder and add a GridView.</span></span> <span data-ttu-id="31f7e-220">Vytvořte nový prvek ObjectDataSource z GridView s inteligentních značek.</span><span class="sxs-lookup"><span data-stu-id="31f7e-220">From the GridView s smart tag, create a new ObjectDataSource.</span></span> <span data-ttu-id="31f7e-221">V prvním kroku průvodce s byste měli vidět `ProductsCL` třídy jako jednu z možností z rozevíracího seznamu.</span><span class="sxs-lookup"><span data-stu-id="31f7e-221">In the wizard s first step you should see the `ProductsCL` class as one of the options from the drop-down list.</span></span>


<span data-ttu-id="31f7e-222">[![Třída ProductsCL je zahrnuta v rozevíracím seznamu obchodní objekt](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span><span class="sxs-lookup"><span data-stu-id="31f7e-222">[![The ProductsCL Class is Included in the Business Object Drop-Down List](caching-data-in-the-architecture-cs/_static/image5.png)](caching-data-in-the-architecture-cs/_static/image4.png)</span></span>

<span data-ttu-id="31f7e-223">**Obrázek 4**: `ProductsCL` třída je zahrnuta v rozevíracím seznamu obchodní objekt ([kliknutím ji zobrazíte obrázek v plné velikosti](caching-data-in-the-architecture-cs/_static/image6.png))</span><span class="sxs-lookup"><span data-stu-id="31f7e-223">**Figure 4**: The `ProductsCL` Class is Included in the Business Object Drop-Down List ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image6.png))</span></span>


<span data-ttu-id="31f7e-224">Po výběru `ProductsCL`, klikněte na tlačítko Další.</span><span class="sxs-lookup"><span data-stu-id="31f7e-224">After selecting `ProductsCL`, click Next.</span></span> <span data-ttu-id="31f7e-225">Rozevírací seznam v kartě vyberte má dvě položky - `GetProducts()` a `GetProductsByCategoryID(categoryID)` a kartu aktualizace má jediný `UpdateProduct` přetížení.</span><span class="sxs-lookup"><span data-stu-id="31f7e-225">The drop-down list in the SELECT tab has two items - `GetProducts()` and `GetProductsByCategoryID(categoryID)` and the UPDATE tab has the sole `UpdateProduct` overload.</span></span> <span data-ttu-id="31f7e-226">Zvolte `GetProducts()` metodu z vyberte kartu a `UpdateProducts` metoda kartu aktualizace a klikněte na Dokončit.</span><span class="sxs-lookup"><span data-stu-id="31f7e-226">Choose the `GetProducts()` method from the SELECT tab and the `UpdateProducts` method from the UPDATE tab and click Finish.</span></span>


<span data-ttu-id="31f7e-227">[![Metody třídy ProductsCL s jsou uvedeny v rozevírací seznamy](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span><span class="sxs-lookup"><span data-stu-id="31f7e-227">[![The ProductsCL Class s Methods are Listed in the Drop-Down Lists](caching-data-in-the-architecture-cs/_static/image8.png)](caching-data-in-the-architecture-cs/_static/image7.png)</span></span>

<span data-ttu-id="31f7e-228">**Obrázek 5**: `ProductsCL` metody třídy s jsou uvedeny v rozevírací seznamy ([kliknutím ji zobrazíte obrázek v plné velikosti](caching-data-in-the-architecture-cs/_static/image9.png))</span><span class="sxs-lookup"><span data-stu-id="31f7e-228">**Figure 5**: The `ProductsCL` Class s Methods are Listed in the Drop-Down Lists ([Click to view full-size image](caching-data-in-the-architecture-cs/_static/image9.png))</span></span>


<span data-ttu-id="31f7e-229">Po dokončení průvodce, Visual Studio nastaví ObjectDataSource s `OldValuesParameterFormatString` vlastnost `original_{0}` a přidejte do příslušných polí do prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="31f7e-229">After completing the wizard, Visual Studio will set the ObjectDataSource s `OldValuesParameterFormatString` property to `original_{0}` and add the appropriate fields to the GridView.</span></span> <span data-ttu-id="31f7e-230">Změnit `OldValuesParameterFormatString` vlastnost zpět na výchozí hodnotu, `{0}`a konfigurace ovládacího prvku GridView pro podporu stránkování, řazení a úpravy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-230">Change the `OldValuesParameterFormatString` property back to its default value, `{0}`, and configure the GridView to support paging, sorting, and editing.</span></span> <span data-ttu-id="31f7e-231">Vzhledem k tomu, `UploadProducts` přetížení používané CL přijímá pouze upravených produkt s názvem a ceny, omezit prvku GridView tak, aby se jenom tato pole upravovat.</span><span class="sxs-lookup"><span data-stu-id="31f7e-231">Since the `UploadProducts` overload used by the CL accepts only the edited product s name and price, limit the GridView so that only these fields are editable.</span></span>

<span data-ttu-id="31f7e-232">V předchozím kurzu jsme definovali GridView pro zahrnutí polí pro `ProductName`, `CategoryName`, a `UnitPrice` pole.</span><span class="sxs-lookup"><span data-stu-id="31f7e-232">In the preceding tutorial we defined a GridView to include fields for the `ProductName`, `CategoryName`, and `UnitPrice` fields.</span></span> <span data-ttu-id="31f7e-233">Nebojte se replikace tohoto formátování a struktura, v takovém případě vašeho ovládacího prvku GridView a prvku ObjectDataSource s deklarativní značek by měl vypadat nějak takto:</span><span class="sxs-lookup"><span data-stu-id="31f7e-233">Feel free to replicate this formatting and structure, in which case your GridView and ObjectDataSource s declarative markup should look similar to the following:</span></span>


[!code-aspx[Main](caching-data-in-the-architecture-cs/samples/sample11.aspx)]

<span data-ttu-id="31f7e-234">V tuto chvíli máme stránku, která používá vrstev ukládání do mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-234">At this point we have a page that uses the Caching Layer.</span></span> <span data-ttu-id="31f7e-235">Pokud chcete zobrazit mezipaměti v akci, nastavte zarážky v `ProductsCL` třída s `GetProducts()` a `UpdateProduct` metody.</span><span class="sxs-lookup"><span data-stu-id="31f7e-235">To see the cache in action, set breakpoints in the `ProductsCL` class s `GetProducts()` and `UpdateProduct` methods.</span></span> <span data-ttu-id="31f7e-236">Na stránce v prohlížeči a krokovat kód při řazení a stránkování, chcete-li zobrazit data získaná z mezipaměti.</span><span class="sxs-lookup"><span data-stu-id="31f7e-236">Visit the page in a browser and step through the code when sorting and paging in order to see the data pulled from the cache.</span></span> <span data-ttu-id="31f7e-237">Potom aktualizovat záznam a Všimněte si, že platnost mezipaměti a v důsledku toho jsou načteny z BLL při dat je znovu připojeno k prvku GridView.</span><span class="sxs-lookup"><span data-stu-id="31f7e-237">Then update a record and note that the cache is invalidated and, consequently, it is retrieved from the BLL when the data is rebound to the GridView.</span></span>

> [!NOTE]
> <span data-ttu-id="31f7e-238">Ukládání do mezipaměti vrstvy k dispozici v souboru pro stažení doprovodném Tento článek není úplný.</span><span class="sxs-lookup"><span data-stu-id="31f7e-238">The Caching Layer provided in the download accompanying this article is not complete.</span></span> <span data-ttu-id="31f7e-239">Obsahuje pouze jednu třídu, `ProductsCL`, která jenom sportovní několik metod.</span><span class="sxs-lookup"><span data-stu-id="31f7e-239">It contains only one class, `ProductsCL`, which only sports a handful of methods.</span></span> <span data-ttu-id="31f7e-240">Kromě toho používá jenom jednu stránku ASP.NET CL (`~/Caching/FromTheArchitecture.aspx`) všechny ostatní stále odkazují BLL přímo.</span><span class="sxs-lookup"><span data-stu-id="31f7e-240">Moreover, only a single ASP.NET page uses the CL (`~/Caching/FromTheArchitecture.aspx`) all others still reference the BLL directly.</span></span> <span data-ttu-id="31f7e-241">Pokud máte v úmyslu používat CL ve vaší aplikaci, všechna volání od prezentační vrstvy by měl přejděte do CL, která by vyžadovala třídy s CL a metody, na něž se tyto třídy a metody v BLL aktuálně používá prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-241">If you plan on using a CL in your application, all calls from the Presentation Layer should go to the CL, which would require that the CL s classes and methods covered those classes and methods in the BLL currently used by the Presentation Layer.</span></span>


## <a name="summary"></a><span data-ttu-id="31f7e-242">Souhrn</span><span class="sxs-lookup"><span data-stu-id="31f7e-242">Summary</span></span>

<span data-ttu-id="31f7e-243">Při ukládání do mezipaměti je možné použít na prezentační vrstvu s ASP.NET 2.0 s SqlDataSource a ovládací prvky prvku ObjectDataSource, by v ideálním případě ukládání do mezipaměti odpovědnosti delegovat na samostatné vrstva v architektuře.</span><span class="sxs-lookup"><span data-stu-id="31f7e-243">While caching can be applied at the Presentation Layer with ASP.NET 2.0 s SqlDataSource and ObjectDataSource controls, ideally caching responsibilities would be delegated to a separate layer in the architecture.</span></span> <span data-ttu-id="31f7e-244">V tomto kurzu jsme vytvořili vrstvu ukládání do mezipaměti, který se nachází mezi prezentační vrstva a vrstva obchodní logiky.</span><span class="sxs-lookup"><span data-stu-id="31f7e-244">In this tutorial we created a Caching Layer that resides between the Presentation Layer and the Business Logic Layer.</span></span> <span data-ttu-id="31f7e-245">Vrstev ukládání do mezipaměti je potřeba zadat stejnou sadu tříd a metod, které existují v knihoven BLL a jsou volány od prezentační vrstvy.</span><span class="sxs-lookup"><span data-stu-id="31f7e-245">The Caching Layer needs to provide the same set of classes and methods that exist in the BLL and are called from the Presentation Layer.</span></span>

<span data-ttu-id="31f7e-246">Došlo k ukládání do mezipaměti vrstvy příklady, Prozkoumali jsme v této a v předchozích kurzech *reaktivní načítání*.</span><span class="sxs-lookup"><span data-stu-id="31f7e-246">The Caching Layer examples we explored in this and the preceding tutorials exhibited *reactive loading*.</span></span> <span data-ttu-id="31f7e-247">S načítáním reaktivní, načtení dat do mezipaměti pouze v případě provedení požadavku na data a tato data z mezipaměti chybí.</span><span class="sxs-lookup"><span data-stu-id="31f7e-247">With reactive loading, the data is loaded into the cache only when a request for the data is made and that data is missing from the cache.</span></span> <span data-ttu-id="31f7e-248">Data mohou být také *proaktivně načíst* do mezipaměti, technika, která načte data do mezipaměti předtím, než je skutečně potřeba.</span><span class="sxs-lookup"><span data-stu-id="31f7e-248">Data can also be *proactively loaded* into the cache, a technique that loads the data into the cache before it is actually needed.</span></span> <span data-ttu-id="31f7e-249">V dalším kurzu uvidíme příklad proaktivní načítání, když se podíváme na tom, jak ukládat do mezipaměti při spuštění aplikace statickými hodnotami.</span><span class="sxs-lookup"><span data-stu-id="31f7e-249">In the next tutorial we'll see an example of proactive loading when we look at how to store static values into the cache at application startup.</span></span>

<span data-ttu-id="31f7e-250">Všechno nejlepší programování!</span><span class="sxs-lookup"><span data-stu-id="31f7e-250">Happy Programming!</span></span>

## <a name="about-the-author"></a><span data-ttu-id="31f7e-251">O autorovi</span><span class="sxs-lookup"><span data-stu-id="31f7e-251">About the Author</span></span>

<span data-ttu-id="31f7e-252">[Scott Meisnerová](http://www.4guysfromrolla.com/ScottMitchell.shtml), Autor sedm ASP/ASP.NET knih a Zakladatel [4GuysFromRolla.com](http://www.4guysfromrolla.com), má práce s Microsoft webových technologiích od roku 1998.</span><span class="sxs-lookup"><span data-stu-id="31f7e-252">[Scott Mitchell](http://www.4guysfromrolla.com/ScottMitchell.shtml), author of seven ASP/ASP.NET books and founder of [4GuysFromRolla.com](http://www.4guysfromrolla.com), has been working with Microsoft Web technologies since 1998.</span></span> <span data-ttu-id="31f7e-253">Scott funguje jako nezávislý konzultant, trainer a zapisovače.</span><span class="sxs-lookup"><span data-stu-id="31f7e-253">Scott works as an independent consultant, trainer, and writer.</span></span> <span data-ttu-id="31f7e-254">Jeho nejnovější knihy [ *Edice nakladatelství Sams naučit sami ASP.NET 2.0 za 24 hodin*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span><span class="sxs-lookup"><span data-stu-id="31f7e-254">His latest book is [*Sams Teach Yourself ASP.NET 2.0 in 24 Hours*](https://www.amazon.com/exec/obidos/ASIN/0672327384/4guysfromrollaco).</span></span> <span data-ttu-id="31f7e-255">Může být dosáhl v [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="31f7e-255">He can be reached at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span> <span data-ttu-id="31f7e-256">nebo prostřednictvím jeho blogu, který lze nalézt v [ http://ScottOnWriting.NET ](http://ScottOnWriting.NET).</span><span class="sxs-lookup"><span data-stu-id="31f7e-256">or via his blog, which can be found at [http://ScottOnWriting.NET](http://ScottOnWriting.NET).</span></span>

## <a name="special-thanks-to"></a><span data-ttu-id="31f7e-257">Speciální k</span><span class="sxs-lookup"><span data-stu-id="31f7e-257">Special Thanks To</span></span>

<span data-ttu-id="31f7e-258">V této sérii kurzů byl recenzován uživatelem mnoho užitečných revidující.</span><span class="sxs-lookup"><span data-stu-id="31f7e-258">This tutorial series was reviewed by many helpful reviewers.</span></span> <span data-ttu-id="31f7e-259">Vedoucí kontrolor pro účely tohoto kurzu byla Teresy Murph.</span><span class="sxs-lookup"><span data-stu-id="31f7e-259">Lead reviewer for this tutorial was Teresa Murph.</span></span> <span data-ttu-id="31f7e-260">Zajímat téma Moje nadcházejících článcích MSDN?</span><span class="sxs-lookup"><span data-stu-id="31f7e-260">Interested in reviewing my upcoming MSDN articles?</span></span> <span data-ttu-id="31f7e-261">Pokud ano, vyřaďte mě řádek na [ mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span><span class="sxs-lookup"><span data-stu-id="31f7e-261">If so, drop me a line at [mitchell@4GuysFromRolla.com.](mailto:mitchell@4GuysFromRolla.com)</span></span>

> [!div class="step-by-step"]
> <span data-ttu-id="31f7e-262">[Předchozí](caching-data-with-the-objectdatasource-cs.md)
> [další](caching-data-at-application-startup-cs.md)</span><span class="sxs-lookup"><span data-stu-id="31f7e-262">[Previous](caching-data-with-the-objectdatasource-cs.md)
[Next](caching-data-at-application-startup-cs.md)</span></span>
